/* Tslint:disable */
/* eslint-disable */
/**
 * conversion-service
 * A webservice with a REST Api which can convert document/media files using different binaries
 *
 * The version of the OpenAPI document: 0.1.13-2
 * Contact: sven.patrick.meier@team-parallax.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export enum EConversionStatus {
    Converted = 'converted',
    Erroneous = 'erroneous',
    InQueue = 'in queue',
    Processing = 'processing'
}

/**
 * 
 * @export
 * @interface IApiConversionFormatResponse
 */
export interface IApiConversionFormatResponse {
    /**
     * 
     * @type {Array<IFormat>}
     * @memberof IApiConversionFormatResponse
     */
    document: Array<IFormat>;
}
/**
 * 
 * @export
 * @interface ICodec
 */
export interface ICodec {
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    canDecode: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    canEncode: boolean;
    /**
     * 
     * @type {string}
     * @memberof ICodec
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    directRendering?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    drawHorizBand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    intraFrameOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    isLossless?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    isLossy?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ICodec
     */
    type: string;
    /**
     * 
     * @type {boolean}
     * @memberof ICodec
     */
    weirdFrameTruncation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ICodec
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IConversionProcessingResponse
 */
export interface IConversionProcessingResponse {
    /**
     * 
     * @type {string}
     * @memberof IConversionProcessingResponse
     */
    conversionId: string;
}
/**
 * 
 * @export
 * @interface IConversionQueueStatus
 */
export interface IConversionQueueStatus {
    /**
     * 
     * @type {Array<IConversionStatus>}
     * @memberof IConversionQueueStatus
     */
    conversions: Array<IConversionStatus>;
    /**
     * 
     * @type {number}
     * @memberof IConversionQueueStatus
     */
    remainingConversions: number;
}
/**
 * 
 * @export
 * @interface IConversionRequestBody
 */
export interface IConversionRequestBody {
    /**
     * 
     * @type {string}
     * @memberof IConversionRequestBody
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionRequestBody
     */
    filename: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionRequestBody
     */
    originalFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionRequestBody
     */
    targetFormat: string;
}
/**
 * 
 * @export
 * @interface IConversionStatus
 */
export interface IConversionStatus {
    /**
     * 
     * @type {string}
     * @memberof IConversionStatus
     */
    conversionId: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionStatus
     */
    sourceFormat: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionStatus
     */
    targetFormat: string;
    /**
     * 
     * @type {string}
     * @memberof IConversionStatus
     */
    path: string;
    /**
     * 
     * @type {number}
     * @memberof IConversionStatus
     */
    retries: number;
    /**
     * 
     * @type {EConversionStatus}
     * @memberof IConversionStatus
     */
    status: EConversionStatus;
}
/**
 * 
 * @export
 * @interface IEncoder
 */
export interface IEncoder {
    /**
     * 
     * @type {string}
     * @memberof IEncoder
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof IEncoder
     */
    directRendering: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IEncoder
     */
    drawHorizBand: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IEncoder
     */
    experimental: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IEncoder
     */
    frameMT: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IEncoder
     */
    sliceMT: boolean;
    /**
     * 
     * @type {string}
     * @memberof IEncoder
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof IEncoder
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IFFmpegCapabilities
 */
export interface IFFmpegCapabilities {
    /**
     * 
     * @type {Array<ICodec>}
     * @memberof IFFmpegCapabilities
     */
    codecs: Array<ICodec>;
    /**
     * 
     * @type {Array<IEncoder>}
     * @memberof IFFmpegCapabilities
     */
    encoders: Array<IEncoder>;
    /**
     * 
     * @type {Array<IFilter>}
     * @memberof IFFmpegCapabilities
     */
    filters: Array<IFilter>;
    /**
     * 
     * @type {Array<IFfmpegFormat>}
     * @memberof IFFmpegCapabilities
     */
    formats: Array<IFfmpegFormat>;
}
/**
 * 
 * @export
 * @interface IFfmpegFormat
 */
export interface IFfmpegFormat {
    /**
     * 
     * @type {boolean}
     * @memberof IFfmpegFormat
     */
    canDemux: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IFfmpegFormat
     */
    canMux: boolean;
    /**
     * 
     * @type {string}
     * @memberof IFfmpegFormat
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof IFfmpegFormat
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IFilter
 */
export interface IFilter {
    /**
     * 
     * @type {string}
     * @memberof IFilter
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof IFilter
     */
    input: string;
    /**
     * 
     * @type {boolean}
     * @memberof IFilter
     */
    multipleInputs: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IFilter
     */
    multipleOutputs: boolean;
    /**
     * 
     * @type {string}
     * @memberof IFilter
     */
    output: string;
    /**
     * 
     * @type {string}
     * @memberof IFilter
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IFormat
 */
export interface IFormat {
    /**
     * 
     * @type {string}
     * @memberof IFormat
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof IFormat
     */
    extension: string;
}
/**
 * 
 * @export
 * @interface IUnsupportedConversionFormatError
 */
export interface IUnsupportedConversionFormatError {
    /**
     * 
     * @type {number}
     * @memberof IUnsupportedConversionFormatError
     */
    errorCode?: number;
    /**
     * 
     * @type {string}
     * @memberof IUnsupportedConversionFormatError
     */
    message: string;
}

/**
 * CapabilitiesApi - axios parameter creator
 * @export
 */
export const CapabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of capabilities and options that can be applied to an FFmpeg command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCapabilities: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCodecs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities/codecs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available encoders FFmpeg is able to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableEncoders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities/encoders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available filters that can be used for conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFilter: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available formats that can be converted with FFmpeg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFormats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapabilitiesApi - functional programming interface
 * @export
 */
export const CapabilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CapabilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of capabilities and options that can be applied to an FFmpeg command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableCapabilities(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFFmpegCapabilities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableCapabilities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableCodecs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ICodec>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableCodecs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all available encoders FFmpeg is able to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableEncoders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IEncoder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableEncoders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all available filters that can be used for conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableFilter(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableFilter(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all available formats that can be converted with FFmpeg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableFormats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IFfmpegFormat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableFormats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CapabilitiesApi - factory interface
 * @export
 */
export const CapabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CapabilitiesApiFp(configuration)
    return {
        /**
         * Returns a list of capabilities and options that can be applied to an FFmpeg command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCapabilities(options?: any): AxiosPromise<IFFmpegCapabilities> {
            return localVarFp.getAvailableCapabilities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCodecs(options?: any): AxiosPromise<Array<ICodec>> {
            return localVarFp.getAvailableCodecs(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available encoders FFmpeg is able to use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableEncoders(options?: any): AxiosPromise<Array<IEncoder>> {
            return localVarFp.getAvailableEncoders(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available filters that can be used for conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFilter(options?: any): AxiosPromise<Array<IFilter>> {
            return localVarFp.getAvailableFilter(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available formats that can be converted with FFmpeg.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFormats(options?: any): AxiosPromise<Array<IFfmpegFormat>> {
            return localVarFp.getAvailableFormats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CapabilitiesApi - interface
 * @export
 * @interface CapabilitiesApi
 */
export interface CapabilitiesApiInterface {
    /**
     * Returns a list of capabilities and options that can be applied to an FFmpeg command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApiInterface
     */
    getAvailableCapabilities(options?: any): AxiosPromise<IFFmpegCapabilities>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApiInterface
     */
    getAvailableCodecs(options?: any): AxiosPromise<Array<ICodec>>;

    /**
     * Returns all available encoders FFmpeg is able to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApiInterface
     */
    getAvailableEncoders(options?: any): AxiosPromise<Array<IEncoder>>;

    /**
     * Returns all available filters that can be used for conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApiInterface
     */
    getAvailableFilter(options?: any): AxiosPromise<Array<IFilter>>;

    /**
     * Returns all available formats that can be converted with FFmpeg.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApiInterface
     */
    getAvailableFormats(options?: any): AxiosPromise<Array<IFfmpegFormat>>;

}

/**
 * CapabilitiesApi - object-oriented interface
 * @export
 * @class CapabilitiesApi
 * @extends {BaseAPI}
 */
export class CapabilitiesApi extends BaseAPI implements CapabilitiesApiInterface {
    /**
     * Returns a list of capabilities and options that can be applied to an FFmpeg command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getAvailableCapabilities(options?: any) {
        return CapabilitiesApiFp(this.configuration).getAvailableCapabilities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getAvailableCodecs(options?: any) {
        return CapabilitiesApiFp(this.configuration).getAvailableCodecs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available encoders FFmpeg is able to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getAvailableEncoders(options?: any) {
        return CapabilitiesApiFp(this.configuration).getAvailableEncoders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available filters that can be used for conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getAvailableFilter(options?: any) {
        return CapabilitiesApiFp(this.configuration).getAvailableFilter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available formats that can be converted with FFmpeg.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public getAvailableFormats(options?: any) {
        return CapabilitiesApiFp(this.configuration).getAvailableFormats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConversionApi - axios parameter creator
 * @export
 */
export const ConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {any} [conversionFile] 
         * @param {string} [originalFormat] 
         * @param {string} [targetFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertFile: async (conversionFile?: any, originalFormat?: string, targetFormat?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (conversionFile !== undefined) { 
                localVarFormParams.append('conversionFile', conversionFile as any);
            }
    
            if (originalFormat !== undefined) { 
                localVarFormParams.append('originalFormat', originalFormat as any);
            }
    
            if (targetFormat !== undefined) { 
                localVarFormParams.append('targetFormat', targetFormat as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * LEGACY VERSION - will be deprecated in the future Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {IConversionRequestBody} iConversionRequestBody 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        convertFileLegacy: async (iConversionRequestBody: IConversionRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iConversionRequestBody' is not null or undefined
            assertParamExists('convertFileLegacy', 'iConversionRequestBody', iConversionRequestBody)
            const localVarPath = `/conversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iConversionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the status of the conversion queue and returns all conversions with their corresponding status and the amount of outstanding conversions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversionQueueStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current status for a conversion given a conversionId
         * @param {string} conversionId Unique identifier for the conversion of a file.
         * @param {boolean} [v2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertedFile: async (conversionId: string, v2?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversionId' is not null or undefined
            assertParamExists('getConvertedFile', 'conversionId', conversionId)
            const localVarPath = `/conversion/{conversionId}`
                .replace(`{${"conversionId"}}`, encodeURIComponent(String(conversionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current status for a conversion given a conversionId If status is \'converted\' the resulting converted file will be available to download.
         * @param {string} conversionId the id of the file-conversion that is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertedFileDownload: async (conversionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversionId' is not null or undefined
            assertParamExists('getConvertedFileDownload', 'conversionId', conversionId)
            const localVarPath = `/conversion/{conversionId}/download`
                .replace(`{${"conversionId"}}`, encodeURIComponent(String(conversionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversionApi - functional programming interface
 * @export
 */
export const ConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {any} [conversionFile] 
         * @param {string} [originalFormat] 
         * @param {string} [targetFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertFile(conversionFile?: any, originalFormat?: string, targetFormat?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertFile(conversionFile, originalFormat, targetFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * LEGACY VERSION - will be deprecated in the future Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {IConversionRequestBody} iConversionRequestBody 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async convertFileLegacy(iConversionRequestBody: IConversionRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertFileLegacy(iConversionRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the status of the conversion queue and returns all conversions with their corresponding status and the amount of outstanding conversions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversionQueueStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IConversionQueueStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversionQueueStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current status for a conversion given a conversionId
         * @param {string} conversionId Unique identifier for the conversion of a file.
         * @param {boolean} [v2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertedFile(conversionId: string, v2?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IConversionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertedFile(conversionId, v2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current status for a conversion given a conversionId If status is \'converted\' the resulting converted file will be available to download.
         * @param {string} conversionId the id of the file-conversion that is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConvertedFileDownload(conversionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConvertedFileDownload(conversionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConversionApi - factory interface
 * @export
 */
export const ConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversionApiFp(configuration)
    return {
        /**
         * Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {any} [conversionFile] 
         * @param {string} [originalFormat] 
         * @param {string} [targetFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertFile(conversionFile?: any, originalFormat?: string, targetFormat?: string, options?: any): AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError> {
            return localVarFp.convertFile(conversionFile, originalFormat, targetFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * LEGACY VERSION - will be deprecated in the future Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
         * @param {IConversionRequestBody} iConversionRequestBody 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        convertFileLegacy(iConversionRequestBody: IConversionRequestBody, options?: any): AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError> {
            return localVarFp.convertFileLegacy(iConversionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the status of the conversion queue and returns all conversions with their corresponding status and the amount of outstanding conversions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversionQueueStatus(options?: any): AxiosPromise<IConversionQueueStatus> {
            return localVarFp.getConversionQueueStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current status for a conversion given a conversionId
         * @param {string} conversionId Unique identifier for the conversion of a file.
         * @param {boolean} [v2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertedFile(conversionId: string, v2?: boolean, options?: any): AxiosPromise<IConversionStatus> {
            return localVarFp.getConvertedFile(conversionId, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current status for a conversion given a conversionId If status is \'converted\' the resulting converted file will be available to download.
         * @param {string} conversionId the id of the file-conversion that is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConvertedFileDownload(conversionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getConvertedFileDownload(conversionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversionApi - interface
 * @export
 * @interface ConversionApi
 */
export interface ConversionApiInterface {
    /**
     * Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
     * @param {any} [conversionFile] 
     * @param {string} [originalFormat] 
     * @param {string} [targetFormat] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApiInterface
     */
    convertFile(conversionFile?: any, originalFormat?: string, targetFormat?: string, options?: any): AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError>;

    /**
     * LEGACY VERSION - will be deprecated in the future Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
     * @param {IConversionRequestBody} iConversionRequestBody 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ConversionApiInterface
     */
    convertFileLegacy(iConversionRequestBody: IConversionRequestBody, options?: any): AxiosPromise<IConversionProcessingResponse | IUnsupportedConversionFormatError>;

    /**
     * Retrieves the status of the conversion queue and returns all conversions with their corresponding status and the amount of outstanding conversions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApiInterface
     */
    getConversionQueueStatus(options?: any): AxiosPromise<IConversionQueueStatus>;

    /**
     * Returns the current status for a conversion given a conversionId
     * @param {string} conversionId Unique identifier for the conversion of a file.
     * @param {boolean} [v2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApiInterface
     */
    getConvertedFile(conversionId: string, v2?: boolean, options?: any): AxiosPromise<IConversionStatus>;

    /**
     * Returns the current status for a conversion given a conversionId If status is \'converted\' the resulting converted file will be available to download.
     * @param {string} conversionId the id of the file-conversion that is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApiInterface
     */
    getConvertedFileDownload(conversionId: string, options?: any): AxiosPromise<any>;

}

/**
 * ConversionApi - object-oriented interface
 * @export
 * @class ConversionApi
 * @extends {BaseAPI}
 */
export class ConversionApi extends BaseAPI implements ConversionApiInterface {
    /**
     * Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
     * @param {any} [conversionFile] 
     * @param {string} [originalFormat] 
     * @param {string} [targetFormat] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApi
     */
    public convertFile(conversionFile?: any, originalFormat?: string, targetFormat?: string, options?: any) {
        return ConversionApiFp(this.configuration).convertFile(conversionFile, originalFormat, targetFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * LEGACY VERSION - will be deprecated in the future Adds the file from the request body to the internal conversion queue. The files in queue will be processed after the FIFO principle.
     * @param {IConversionRequestBody} iConversionRequestBody 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ConversionApi
     */
    public convertFileLegacy(iConversionRequestBody: IConversionRequestBody, options?: any) {
        return ConversionApiFp(this.configuration).convertFileLegacy(iConversionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the status of the conversion queue and returns all conversions with their corresponding status and the amount of outstanding conversions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApi
     */
    public getConversionQueueStatus(options?: any) {
        return ConversionApiFp(this.configuration).getConversionQueueStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current status for a conversion given a conversionId
     * @param {string} conversionId Unique identifier for the conversion of a file.
     * @param {boolean} [v2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApi
     */
    public getConvertedFile(conversionId: string, v2?: boolean, options?: any) {
        return ConversionApiFp(this.configuration).getConvertedFile(conversionId, v2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current status for a conversion given a conversionId If status is \'converted\' the resulting converted file will be available to download.
     * @param {string} conversionId the id of the file-conversion that is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionApi
     */
    public getConvertedFileDownload(conversionId: string, options?: any) {
        return ConversionApiFp(this.configuration).getConvertedFileDownload(conversionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConversionFormatsApi - axios parameter creator
 * @export
 */
export const ConversionFormatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedConversionFormats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversionFormatsApi - functional programming interface
 * @export
 */
export const ConversionFormatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversionFormatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedConversionFormats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IApiConversionFormatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedConversionFormats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConversionFormatsApi - factory interface
 * @export
 */
export const ConversionFormatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversionFormatsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedConversionFormats(options?: any): AxiosPromise<IApiConversionFormatResponse> {
            return localVarFp.getSupportedConversionFormats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversionFormatsApi - interface
 * @export
 * @interface ConversionFormatsApi
 */
export interface ConversionFormatsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionFormatsApiInterface
     */
    getSupportedConversionFormats(options?: any): AxiosPromise<IApiConversionFormatResponse>;

}

/**
 * ConversionFormatsApi - object-oriented interface
 * @export
 * @class ConversionFormatsApi
 * @extends {BaseAPI}
 */
export class ConversionFormatsApi extends BaseAPI implements ConversionFormatsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionFormatsApi
     */
    public getSupportedConversionFormats(options?: any) {
        return ConversionFormatsApiFp(this.configuration).getSupportedConversionFormats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingResponse: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingResponse(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPingResponse(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingResponse(options?: any): AxiosPromise<string> {
            return localVarFp.getPingResponse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscApi - interface
 * @export
 * @interface MiscApi
 */
export interface MiscApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApiInterface
     */
    getPingResponse(options?: any): AxiosPromise<string>;

}

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI implements MiscApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public getPingResponse(options?: any) {
        return MiscApiFp(this.configuration).getPingResponse(options).then((request) => request(this.axios, this.basePath));
    }
}


